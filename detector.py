# -*- coding: utf-8 -*-
"""Detector.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CChlGK8GcKftI84D0mIUmTtOm4B5JasM
"""

pip install adversarial-robustness-toolbox

# Commented out IPython magic to ensure Python compatibility.
import warnings
warnings.filterwarnings('ignore')

from keras.applications.resnet50 import ResNet50
from keras.models import Model
from keras.models import load_model
from art import config
from art.utils import load_dataset, get_file
from art.estimators.classification import KerasClassifier
from art.attacks.evasion import FastGradientMethod
from art.defences.detector.evasion import BinaryInputDetector

import numpy as np
import pickle

# %matplotlib inline
import matplotlib.pyplot as plt

with open('/content/drive/MyDrive/VGG16_ASS2/vgg_16_train.pickle', 'rb') as f:
    x_train_n, y_train_n = pickle.load(f)

with open('/content/drive/MyDrive/VGG16_ASS2/vgg_16_test.pickle', 'rb') as f:
    x_test_n, y_test_n = pickle.load(f)

with open('/content/drive/MyDrive/res50_dai_ass2/res50_x_test_adv_fgsmntar.pickle', 'rb') as f:
    x_test_adv_fgsm_nt = pickle.load(f)

with open('/content/drive/MyDrive/res50_dai_ass2/res50_x_train_adv_fgsmntar.pickle', 'rb') as f:
    x_train_adv_fgsm_nt = pickle.load(f)

import tensorflow as tf

tf.compat.v1.disable_eager_execution()

#path = get_file('/content/drive/MyDrive/res50_dai_ass2/res50_24_01_2021_img_size64.h5')
detector_model = load_model('/content/drive/MyDrive/res50_dai_ass2/res50_24_01_2021_img_size64.h5')
detector_model.compile(loss='categorical_crossentropy', optimizer='adam',metrics=['accuracy'])
detector_classifier = KerasClassifier(clip_values=(-0.5, 0.5), model=detector_model, use_logits=False)
detector = BinaryInputDetector(detector_classifier)

#x_train_adv = attacker.generate(x_train)
nb_train = x_train_adv_fgsm_nt.shape[0]

x_train_detector = np.concatenate((x_train_n, x_train_adv_fgsm_nt), axis=0)
y_train_detector = np.concatenate((np.array([[1,0]]*nb_train), np.array([[0,1]]*nb_train)), axis=0)

detector.fit(x_train_detector, y_train_detector, nb_epochs=2, batch_size=20)

